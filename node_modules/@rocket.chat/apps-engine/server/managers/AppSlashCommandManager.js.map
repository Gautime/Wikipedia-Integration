{"version":3,"sources":["src/server/managers/AppSlashCommandManager.ts"],"names":[],"mappings":"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","file":"AppSlashCommandManager.js","sourcesContent":["import { AppStatusUtils } from '../../definition/AppStatus';\nimport { AppMethod } from '../../definition/metadata';\nimport { ISlashCommand, ISlashCommandPreview, ISlashCommandPreviewItem, SlashCommandContext } from '../../definition/slashcommands';\n\nimport { AppManager } from '../AppManager';\nimport { IAppCommandBridge } from '../bridges';\nimport { CommandAlreadyExistsError, CommandHasAlreadyBeenTouchedError } from '../errors';\nimport { Room } from '../rooms/Room';\nimport { AppAccessorManager } from './AppAccessorManager';\nimport { AppSlashCommand } from './AppSlashCommand';\n\n/**\n * The command manager for the Apps.\n *\n * An App will add commands during their `initialize` method.\n * Then once an App's `onEnable` is called and it returns true,\n * only then will that App's commands be enabled.\n *\n * Registered means the command has been provided to the bridged system.\n */\nexport class AppSlashCommandManager {\n    private readonly bridge: IAppCommandBridge;\n    private readonly accessors: AppAccessorManager;\n    // Variable that contains the commands which have been provided by apps.\n    // The key of the top map is app id and the key of the inner map is the command\n    private providedCommands: Map<string, Map<string, AppSlashCommand>>;\n    // Contains the commands which have modified the system commands\n    private modifiedCommands: Map<string, AppSlashCommand>;\n    // Contains the commands as keys and appId that touched it.\n    // Doesn't matter whether the app provided, modified, disabled, or enabled.\n    // As long as an app touched the command (besides to see if it exists), then it is listed here.\n    private touchedCommandsToApps: Map<string, string>;\n    // Contains the apps and the commands they have touched. The key is the appId and value is the commands.\n    // Doesn't matter whether the app provided, modified, disabled, or enabled.\n    // As long as an app touched the command (besides to see if it exists), then it is listed here.\n    private appsTouchedCommands: Map<string, Array<string>>;\n\n    constructor(private readonly manager: AppManager) {\n        this.bridge = this.manager.getBridges().getCommandBridge();\n        this.accessors = this.manager.getAccessorManager();\n        this.touchedCommandsToApps = new Map<string, string>();\n        this.appsTouchedCommands = new Map<string, Array<string>>();\n        this.providedCommands = new Map<string, Map<string, AppSlashCommand>>();\n        this.modifiedCommands = new Map<string, AppSlashCommand>();\n    }\n\n    /**\n     * Checks whether an App can touch a command or not. There are only two ways an App can touch\n     * a command:\n     * 1. The command has yet to be touched\n     * 2. The app has already touched the command\n     *\n     * When do we consider an App touching a command? Whenever it adds, modifies,\n     * or removes one that it didn't provide.\n     *\n     * @param appId the app's id which to check for\n     * @param command the command to check about\n     * @returns whether or not the app can touch the command\n     */\n    public canCommandBeTouchedBy(appId: string, command: string): boolean {\n        const cmd = command.toLowerCase().trim();\n        return cmd && (!this.touchedCommandsToApps.has(cmd) || this.touchedCommandsToApps.get(cmd) === appId);\n    }\n\n    /**\n     * Determines whether the command is already provided by an App or not.\n     * It is case insensitive.\n     *\n     * @param command the command to check if it exists or not\n     * @returns whether or not it is already provided\n     */\n    public isAlreadyDefined(command: string): boolean {\n        const search = command.toLowerCase().trim();\n        let exists: boolean = false;\n\n        this.providedCommands.forEach((cmds) => {\n            if (cmds.has(search)) {\n                exists = true;\n            }\n        });\n\n        return exists;\n    }\n\n    /**\n     * Adds a command to *be* registered. This will *not register* it with the\n     * bridged system yet as this is only called on an App's\n     * `initialize` method and an App might not get enabled.\n     * When adding a command, it can *not* already exist in the system\n     * (to overwrite) and another App can *not* have already touched or provided it.\n     * Apps are on a first come first serve basis for providing and modifying commands.\n     *\n     * @param appId the app's id which the command belongs to\n     * @param command the command to add to the system\n     */\n    public addCommand(appId: string, command: ISlashCommand): void {\n        command.command = command.command.toLowerCase().trim();\n\n        // Ensure the app can touch this command\n        if (!this.canCommandBeTouchedBy(appId, command.command)) {\n            throw new CommandHasAlreadyBeenTouchedError(command.command);\n        }\n\n        // Verify the command doesn't exist already\n        if (this.bridge.doesCommandExist(command.command, appId) || this.isAlreadyDefined(command.command)) {\n            throw new CommandAlreadyExistsError(command.command);\n        }\n\n        const app = this.manager.getOneById(appId);\n        if (!app) {\n            throw new Error('App must exist in order for a command to be added.');\n        }\n\n        if (!this.providedCommands.has(appId)) {\n            this.providedCommands.set(appId, new Map<string, AppSlashCommand>());\n        }\n\n        this.providedCommands.get(appId).set(command.command, new AppSlashCommand(app, command));\n\n        // The app has now touched the command, so let's set it\n        this.setAsTouched(appId, command.command);\n    }\n\n    /**\n     * Modifies an existing command. The command must either be the App's\n     * own command or a system command. One App can not modify another\n     * App's command. Apps are on a first come first serve basis as to whether\n     * or not they can touch or provide a command. If App \"A\" first provides,\n     * or overwrites, a command then App \"B\" can not touch that command.\n     *\n     * @param appId the app's id of the command to modify\n     * @param command the modified command to replace the current one with\n     */\n    public modifyCommand(appId: string, command: ISlashCommand): void {\n        command.command = command.command.toLowerCase().trim();\n\n        // Ensure the app can touch this command\n        if (!this.canCommandBeTouchedBy(appId, command.command)) {\n            throw new CommandHasAlreadyBeenTouchedError(command.command);\n        }\n\n        const app = this.manager.getOneById(appId);\n        if (!app) {\n            throw new Error('App must exist in order to modify a command.');\n        }\n\n        const hasNotProvidedIt = !this.providedCommands.has(appId) || !this.providedCommands.get(appId).has(command.command);\n\n        // They haven't provided (added) it and the bridged system doesn't have it, error out\n        if (hasNotProvidedIt && !this.bridge.doesCommandExist(command.command, appId)) {\n            throw new Error('You must first register a command before you can modify it.');\n        }\n\n        if (hasNotProvidedIt) {\n            this.bridge.modifyCommand(command, appId);\n            const regInfo = new AppSlashCommand(app, command);\n            regInfo.isDisabled = false;\n            regInfo.isEnabled = true;\n            regInfo.isRegistered = true;\n            this.modifiedCommands.set(command.command, regInfo);\n        } else {\n            this.providedCommands.get(appId).get(command.command).slashCommand = command;\n        }\n\n        this.setAsTouched(appId, command.command);\n    }\n\n    /**\n     * Goes and enables a command in the bridged system. The command\n     * which is being enabled must either be the App's or a system\n     * command which has yet to be touched by an App.\n     *\n     * @param appId the id of the app enabling the command\n     * @param command the command which is being enabled\n     */\n    public enableCommand(appId: string, command: string): void {\n        const cmd = command.toLowerCase().trim();\n\n        // Ensure the app can touch this command\n        if (!this.canCommandBeTouchedBy(appId, cmd)) {\n            throw new CommandHasAlreadyBeenTouchedError(cmd);\n        }\n\n        // Handle if the App provided the command fist\n        if (this.providedCommands.has(appId) && this.providedCommands.get(appId).has(cmd)) {\n            const cmdInfo = this.providedCommands.get(appId).get(cmd);\n\n            // A command marked as disabled can then be \"enabled\" but not be registered.\n            // This happens when an App is not enabled and they change the status of\n            // command based upon a setting they provide which a User can change.\n            if (!cmdInfo.isRegistered) {\n                cmdInfo.isDisabled = false;\n                cmdInfo.isEnabled = true;\n            }\n\n            return;\n        }\n\n        if (!this.bridge.doesCommandExist(cmd, appId)) {\n            throw new Error(`The command \"${cmd}\" does not exist to enable.`);\n        }\n\n        this.bridge.enableCommand(cmd, appId);\n        this.setAsTouched(appId, cmd);\n    }\n\n    /**\n     * Renders an existing slash command un-usable. Whether that command is provided\n     * by the App calling this or a command provided by the bridged system, we don't care.\n     * However, an App can not disable a command which has already been touched\n     * by another App in some way.\n     *\n     * @param appId the app's id which is disabling the command\n     * @param command the command to disable in the bridged system\n     */\n    public disableCommand(appId: string, command: string): void {\n        const cmd = command.toLowerCase().trim();\n\n        // Ensure the app can touch this command\n        if (!this.canCommandBeTouchedBy(appId, cmd)) {\n            throw new CommandHasAlreadyBeenTouchedError(cmd);\n        }\n\n        // Handle if the App provided the command fist\n        if (this.providedCommands.has(appId) && this.providedCommands.get(appId).has(cmd)) {\n            const cmdInfo = this.providedCommands.get(appId).get(cmd);\n\n            // A command marked as enabled can then be \"disabled\" but not yet be registered.\n            // This happens when an App is not enabled and they change the status of\n            // command based upon a setting they provide which a User can change.\n            if (!cmdInfo.isRegistered) {\n                cmdInfo.isDisabled = true;\n                cmdInfo.isEnabled = false;\n            }\n\n            return;\n        }\n\n        if (!this.bridge.doesCommandExist(cmd, appId)) {\n            throw new Error(`The command \"${cmd}\" does not exist to disable.`);\n        }\n\n        this.bridge.disableCommand(cmd, appId);\n        this.setAsTouched(appId, cmd);\n    }\n\n    /**\n     * Registers all of the commands for the provided app inside\n     * of the bridged system which then enables them.\n     *\n     * @param appId The app's id of which to register it's commands with the bridged system\n     */\n    public registerCommands(appId: string): void {\n        if (!this.providedCommands.has(appId)) {\n            return;\n        }\n\n        this.providedCommands.get(appId).forEach((r) => {\n            if (r.isDisabled) {\n                return;\n            }\n\n            this.registerCommand(appId, r);\n        });\n    }\n\n    /**\n     * Unregisters the commands from the system and restores the commands\n     * which the app modified in the system.\n     *\n     * @param appId the appId for the commands to purge\n     */\n    public unregisterCommands(appId: string): void {\n        if (this.providedCommands.has(appId)) {\n            this.providedCommands.get(appId).forEach((r) => {\n                this.bridge.unregisterCommand(r.slashCommand.command, appId);\n                this.touchedCommandsToApps.delete(r.slashCommand.command);\n                const ind = this.appsTouchedCommands.get(appId).indexOf(r.slashCommand.command);\n                this.appsTouchedCommands.get(appId).splice(ind, 1);\n                r.isRegistered = true;\n            });\n\n            this.providedCommands.delete(appId);\n        }\n\n        if (this.appsTouchedCommands.has(appId)) {\n            // The commands inside the appsTouchedCommands should now\n            // only be the ones which the App has enabled, disabled, or modified.\n            // We call restore to enable the commands provided by the bridged system\n            // or unmodify the commands modified by the App\n            this.appsTouchedCommands.get(appId).forEach((cmd) => {\n                this.bridge.restoreCommand(cmd, appId);\n                this.modifiedCommands.get(cmd).isRegistered = false;\n                this.modifiedCommands.delete(cmd);\n                this.touchedCommandsToApps.delete(cmd);\n            });\n\n            this.appsTouchedCommands.delete(appId);\n        }\n    }\n\n    /**\n     * Executes an App's command.\n     *\n     * @param command the command to execute\n     * @param context the context in which the command was entered\n     */\n    public async executeCommand(command: string, context: SlashCommandContext): Promise<void> {\n        const cmd = command.toLowerCase().trim();\n\n        if (!this.shouldCommandFunctionsRun(cmd)) {\n            return;\n        }\n\n        const app = this.manager.getOneById(this.touchedCommandsToApps.get(cmd));\n\n        if (!app || AppStatusUtils.isDisabled(app.getStatus())) {\n            // Just in case someone decides to do something they shouldn't\n            // let's ensure the app actually exists\n            return;\n        }\n\n        const appCmd = this.retrieveCommandInfo(cmd, app.getID());\n        await appCmd.runExecutorOrPreviewer(AppMethod._COMMAND_EXECUTOR, this.ensureContext(context), this.manager.getLogStorage(), this.accessors);\n\n        return;\n    }\n\n    public async getPreviews(command: string, context: SlashCommandContext): Promise<ISlashCommandPreview> {\n        const cmd = command.toLowerCase().trim();\n\n        if (!this.shouldCommandFunctionsRun(cmd)) {\n            return;\n        }\n\n        const app = this.manager.getOneById(this.touchedCommandsToApps.get(cmd));\n\n        if (!app || AppStatusUtils.isDisabled(app.getStatus())) {\n            // Just in case someone decides to do something they shouldn't\n            // let's ensure the app actually exists\n            return;\n        }\n\n        const appCmd = this.retrieveCommandInfo(cmd, app.getID());\n\n        // tslint:disable-next-line:max-line-length\n        const result = await appCmd.runExecutorOrPreviewer(AppMethod._COMMAND_PREVIEWER, this.ensureContext(context), this.manager.getLogStorage(), this.accessors);\n\n        if (!result) {\n            // Failed to get the preview, thus returning is fine\n            return;\n        }\n\n        return result;\n    }\n\n    public async executePreview(command: string, previewItem: ISlashCommandPreviewItem, context: SlashCommandContext): Promise<ISlashCommandPreview> {\n        const cmd = command.toLowerCase().trim();\n\n        if (!this.shouldCommandFunctionsRun(cmd)) {\n            return;\n        }\n\n        const app = this.manager.getOneById(this.touchedCommandsToApps.get(cmd));\n\n        if (!app || AppStatusUtils.isDisabled(app.getStatus())) {\n            // Just in case someone decides to do something they shouldn't\n            // let's ensure the app actually exists\n            return;\n        }\n\n        const appCmd = this.retrieveCommandInfo(cmd, app.getID());\n        await appCmd.runPreviewExecutor(previewItem, this.ensureContext(context), this.manager.getLogStorage(), this.accessors);\n\n        return;\n    }\n\n    private ensureContext(context: SlashCommandContext): SlashCommandContext {\n        // Due to the internal changes for the usernames property, we need to ensure the room\n        // is a class and not just an interface\n        let room: Room;\n        if (context.getRoom() instanceof Room) {\n            room = context.getRoom() as Room;\n        } else {\n            room = new Room(context.getRoom(), this.manager);\n        }\n\n        return new SlashCommandContext(context.getSender(), room, context.getArguments());\n    }\n\n    /**\n     * Determines if the command's functions should run,\n     * this way the code isn't duplicated three times.\n     *\n     * @param command the lowercase and trimmed command\n     * @returns whether or not to continue\n     */\n    private shouldCommandFunctionsRun(command: string): boolean {\n        // None of the Apps have touched the command to execute,\n        // thus we don't care so exit out\n        if (!this.touchedCommandsToApps.has(command)) {\n            return false;\n        }\n\n        const appId = this.touchedCommandsToApps.get(command);\n        const cmdInfo = this.retrieveCommandInfo(command, appId);\n\n        // Should the command information really not exist\n        // Or if the command hasn't been registered\n        // Or the command is disabled on our side\n        // then let's not execute it, as the App probably doesn't want it yet\n        if (!cmdInfo || !cmdInfo.isRegistered || cmdInfo.isDisabled) {\n            return false;\n        }\n\n        return true;\n    }\n\n    private retrieveCommandInfo(command: string, appId: string): AppSlashCommand {\n        return this.modifiedCommands.get(command) || this.providedCommands.get(appId).get(command);\n    }\n\n    /**\n     * Sets that an App has been touched.\n     *\n     * @param appId the app's id which has touched the command\n     * @param command the command, lowercase and trimmed, which has been touched\n     */\n    private setAsTouched(appId: string, command: string): void {\n        if (!this.appsTouchedCommands.has(appId)) {\n            this.appsTouchedCommands.set(appId, new Array<string>());\n        }\n\n        if (!this.appsTouchedCommands.get(appId).includes(command)) {\n            this.appsTouchedCommands.get(appId).push(command);\n        }\n\n        this.touchedCommandsToApps.set(command, appId);\n    }\n\n    /**\n     * Actually goes and provide's the bridged system with the command information.\n     *\n     * @param appId the app which is providing the command\n     * @param info the command's registration information\n     */\n    private registerCommand(appId: string, info: AppSlashCommand): void {\n        this.bridge.registerCommand(info.slashCommand, appId);\n        info.hasBeenRegistered();\n    }\n}\n"]}